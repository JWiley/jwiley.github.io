\documentclass[hyperref={colorlinks=true},presentation]{beamer}
\mode<presentation> {
  \usetheme{Boadilla}
  \usecolortheme{seahorse}
}
\mode<handout> {
  \usetheme{default}
  \usepackage{pgfpages}
  \pgfpagesuselayout{4 on 1}[letterpaper,landscape,border shrink=5mm]
}
\usepackage{amsmath, amsthm, amssymb, Sweave, endnotes, hyperref}
\title[R Graphics]{Creatings Plots \& Graphs in R}
\author[J. Wiley]{Joshua Wiley}
\institute[UCLA]{
  Health Psychology Program \\
  University of California, Los Angeles \\
  \texttt{wileyj@ucla.edu}
}
\date[Spring 2012]{Thursday, 26 April, 2012}

\setbeameroption{hide notes}

\SweaveOpts{keep.source=TRUE}

\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}
\begin{document}
\setkeys{Gin}{width=1.4\textwidth}
<<echo=FALSE>>=
options(width = 60)
@
\renewcommand{\baselinestretch}{1.25}
\normalsize

\begin{frame}[plain]
\maketitle
\end{frame}

\begin{frame}[plain, fragile]
\begin{changemargin}{-2.4cm}{-.5cm}
\begin{figure}
<<fig=TRUE, echo=FALSE, width=12, height=6.75 >>=
## base <- ifelse(grepl("PC", Sys.info()['nodename']),
##   "S:/", "~/Documents/")
## setwd(file.path(base, "Workshops/HPRC_RGraphics"))
infert <- within(infert, {
  case <- factor(case, labels = c("Control", "Case"))
  spontaneous <- factor(spontaneous, labels = c("0", "1", "2+"))
})

require(ggplot2)
require(scales)
p <-
  ggplot(infert, aes(x = "", fill = spontaneous)) +
  geom_bar(width = 1, position = "fill") +
  coord_polar(theta = "y") +
  facet_grid(case ~ education, margins = TRUE)

print(p +
  labs(x = "Condition", y = "Education") +
  scale_y_continuous(labels = percent) +
  scale_fill_discrete(name = "Number of \n abortions") +
  opts(title = "Number of abortions conditional on condition and education \n (with marginal totals)"))
@
\end{figure}
\end{changemargin}
\end{frame}

% \begin{frame}[plain]
% \begin{quotation}
% This reminds me of a quote I saw once (I think it may have been in one of those
% Murphy's Laws calendars), my parahpase:

% If you make someone think that they are thinking,
%       They will love you for it.
% If you make them actually think,
%       They will hate you for it.

% This explains why people love pie charts and hate more effective graphs.
%    -- Greg Snow
%       R-help (December 2009)
% \end{quotation}
% \end{frame}

\AtBeginSection[] {
\begin{frame}{Table of Contents}
\tableofcontents[currentsection]
\end{frame}
}

%  Most of the resources mentioned in this presentation are freely available on the WWW.  Hyperlinks are included for all of these as they are mentioned in the text.

\section{Introduction to R}
\note{
  \begin{itemize}
    \item This presentation gives a \emph{very} brief introduction to \texttt{R}.  The point is just to give enough of a sense that the rest of the presentation makes some sense, not that you know \texttt{R} after this.
    \item Most time is spent describing and showing examples from the \texttt{ggplot2} package for graphics, emphasizing bar charts, pie charts, and chloropleth maps
    \item I sneak in a few other graphs because I could not resist, some cool ones in \texttt{ggplot2} and heatmaps.
  \end{itemize}
}

\begin{frame}
  \frametitle{Getting Started I}
  \texttt{R} is composed of a core set of packages that provide infrastructure and basic functionality and over 3,671 packages.  Most regular \texttt{R} users use some interface.  Popular ones include Rstudio (which I will demonstrate here) and Emacs + ESS.  These provide features to make working with \texttt{R} easier and more efficient.
\begin{itemize}
\setlength{\itemindent}{3em}
  \item[R] \href{http://www.r-project.org/}{http://www.r-project.org/}
  \item[Rstudio] \href{http://rstudio.org/}{http://rstudio.org/}
  \item[Emacs] \href{http://www.gnu.org/software/emacs/}{http://www.gnu.org/software/emacs/}
  \item[ESS] \href{http://ess.r-project.org/}{http://ess.r-project.org/}
  \item[Emacs+ESS] \href{http://vgoulet.act.ulaval.ca/en/emacs/}{http://vgoulet.act.ulaval.ca/en/emacs/}\\(a prebuilt version of Emacs and ESS for Windows or Mac)
\end{itemize}
\note{
  \begin{itemize}
    \item Core developers write and maintain core packages which include packages for the most common, basic tasks, and the R interpreter
    \item Thousands of community written packages extend this core to include and amazing among of flexibility
    \item Rstudio is a popular Integrated Development Environment (IDE) for \texttt{R}.  Along similar lines is Eclipse + StatEt.
    \item Also popular is Emacs (a powerful text editor) + ESS (emacs speaks statistics), an Emacs add on that makes it ``R aware''---automatically submit lines of code, get results, syntax highlighting, etc.
  \end{itemize}
}
\end{frame}

\begin{frame}
  \frametitle{Getting Started II}
\begin{itemize}
\setlength{\itemindent}{3em}
  \item[Tutorial 1] \href{http://www.burns-stat.com/pages/tutorials.html}{http://www.burns-stat.com/pages/tutorials.html}\\read the tutorials for R beginning ($\sim 1$ day)
  \item[Tutorial 2] \href{http://cran.r-project.org/doc/manuals/R-intro.pdf}{http://cran.r-project.org/doc/manuals/R-intro.pdf}\\(through Appendix A) ($\sim 1$ day)
  \item[Tutorial 3] \href{http://www.burns-stat.com/pages/tutorials.html}{http://www.burns-stat.com/pages/tutorials.html}\\intermediate guide, ``The R Inferno'' ($\sim$ 1-3 days)
\end{itemize}

\begin{center}
\textbf{Please stop me if you have questions!}
\end{center}
\note{
  \begin{itemize}
    \item When I say approximately 1 day, I mean 8-10 hours of work, but this is assuming that you are installing \texttt{R}, and actually playing with and trying code as you read
    \item Patrick Burns is a statistician who has written several popular tutorials
    \item The introduction to \texttt{R} manual is the official introductory manual
    \item I am guessing to thoroughly go through all of these would take about a week, after that you should have enough background to do basic things and learn on your own.  For example, be able to read the documentation to learn a new function, and you will have the basic foundation to interact with other \texttt{R} users, ask and understand questions.
  \end{itemize}
}
\end{frame}

\begin{frame}
 \frametitle{R Basics}
\begin{itemize}
 \item Nearly everything in R is an \emph{object}
 \item Objects can be assigned using the assignment operator, ``<-''
 \item \emph{Objects have classes} ranging from basic to complex, such as
 \begin{itemize}
   \item numeric vectors
   \item a class that contains coordinates (latitude, longitude, elevation) and time
   \item a graphical object containing all necessary information to produce a graph
 \end{itemize}
 \item Functions do things, and \emph{functions have methods}
 \item Depending on the \emph{class} of an object passed to a function, different methods will be dispatched.
\end{itemize}
\note{
  \begin{itemize}
    \item This is all covered in the introductory manual, also see:
    \item \textit{Introductory Statistics with R} by Peter Dalgaard (one of the core developers)
    \item \textit{Using R for Introductory Statistics} by John Verzani
    \item \texttt{ggplot2, lattice, grid} tend to create graphical objects more than base graphics can
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
 \frametitle{Examples}
An object's class affects how a function behaves
<<>>=
x <- c(1, 2, 3, 1, 2, 3)
class(x)
print(x)
x <- factor(x)
class(x)
print(x)
@
\note{
  \begin{itemize}
    \item A factor is essentially just indicating categorical data
    \item Compared with character data, factors can be ordered or have levels so that there can be a reference group.  In statistical models, factors are usually automatically dummy coded.
    \item Depending on the class of the object, x, the behavior of \texttt{print} changes (it adds the levels info for factors)
  \end{itemize}
}
\end{frame}

\begin{frame}
  \frametitle{R Basics II}
\begin{itemize}
  \item This is just Object Oriented Programming (OOP).  Whether numbers are numeric or factor class can dramatically change the graph created.
  \item The most common data structure in R is a data frame; a matrix where each column can be a vector of a different class.
  \item \texttt{str()} is a useful function to show the \textbf{str}ucture of an object.  We could look at the data frame (called \textbf{infert}) that the pie charts were based on.
\end{itemize}
\note{
  \begin{itemize}
    \item Not only are data frames the most common, many functions create data frames by default and many others expect data frames
    \item For example, \texttt{read.table, read.csv} create data frames; \texttt{ggplot} the base function in the \texttt{ggplot2} package expects a data frame input.
    \item Beginners often run into difficulties and sometimes strange error messages because data are not in the correct format.  \texttt{str} can help with this because it can show that a column you think is numeric is actually character.  Perhaps on further investigation, ``.'' were used for missing values, but not declared as such when using \texttt{read.table} to read the data in, so \texttt{R} treated the entire column as character.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Examples II}
<<>>=
str(infert)
@
\note{
  \begin{itemize}
    \item Here you see that \textbf{infert} is a data frame where the observations are the number of rows and the variables the number of columns
    \item It also shows the name of every column (variable) in the data frame, the class of that particular variable, and a few example values from the first couple rows
    \item For factors it displays the number of levels, \texttt{num = numeric}, \texttt{int = integer}, \texttt{char = character}
    \item The ``\$'' can be used to access a particular variable.  For example, ``infert\$age'' would point to the variable, age, in the dataset infert.
  \end{itemize}
}
\end{frame}

\begin{frame}
  \frametitle{R Graphics}
There are three main graphing systems in \texttt{R}
\begin{itemize}
  \item traditional graphics (included in the core \texttt{R} packages)
  \item lattice (in the \textbf{lattice} package)
  \item ggplot2 (in the \textbf{ggplot2} package)
\end{itemize}
I am going to focus on \texttt{ggplot2} in this presentation.  For a more detailed overview, I suggest \textit{R Graphics} by Paul Murrell (2nd Ed.).
\note{
  \begin{itemize}
    \item I call these ``systems'' because each one is heavily used and has other user written packages that extend their functionality.  \texttt{grid} could be added to this list as it is the underlying framework used by both \texttt{lattice} and \texttt{ggplot2}, but it is low level, and many users use \texttt{ggplot2} without ever directly using \texttt{grid}.
    \item \textit{R Graphics} provides details about how and why these systems work.  For a ``cookbook'', I would just search online.  Many, many blogs and websites have numerous examples of graphs created in \texttt{R}.  There are also some purchasable graphics cookbooks.
  \end{itemize}
}
\end{frame}

\section{ggplot2}
\note{
  \begin{itemize}
    \item grammar of graphics plot 2 by Hadley Wickham
    \item Hadley Wickham is a statistician at Rice University
    \item \texttt{ggplot2} has an active ($\sim$ 20 emails per day) support listserv and now developer listserv
  \end{itemize}
}

\begin{frame}
  \frametitle{ggplot2 background I}
\begin{itemize}
  \item Before we dive into examples of graphics in \texttt{ggplot2}, I want to give a bit of background.
  \item \texttt{ggplot2} is based on the \textbf{g}rammar of \textbf{g}raphics, a framework for creating graphs.
  \item The idea is that graphics or data visualization generally can be broken down into basic low level pieces and then combined, like language, into a final product.
\end{itemize}
\note{
  \begin{itemize}
    \item \textit{Grammar of Graphics} is actually a theory (and a book) by Leland Wilkinson
    \item It is used now in IBM SPSS in what they call \texttt{GPL} or Graphics Processing Language
    \item Because it is very different from how many people think about plots and graphs, it can be tricky at first, but after learning it, I find it a very natural, flexible way to express data as graphics
  \end{itemize}
}
\end{frame}

\begin{frame}
  \frametitle{ggplot2 background II}
\begin{itemize}
  \item For example, this sentence is valid: ``This is a lamp.'' but the sentence can be modified without recreating it: ``This is a red lamp.''.

  \item This powerful concept allows basic aspects of graphs to be reused and slight modifications added rather than starting from scratch each time.

  \item Under this system, line plots and scatter plots are essentially the same.  Both have data mapped to the x and y axes.  The difference is the plotting symbol (called a \textbf{geom} in \texttt{ggplot2}) is a point or line.  The data, axes, labels, titles, etc. can be identical in both cases.
\end{itemize}
\note{
  \begin{itemize}
    \item I will emphasize this theme of how plots are the same and where they differ throughout this presentation
    \item Hopefully this will make the grammar of graphics (and thus \texttt{ggplot2}) make more sense
    \item also, I believe it is a helpful way to conceptualize \emph{any} graphic, even if it is not being made in a system that uses the grammar
  \end{itemize}
}
\end{frame}

\subsection{Bar and Pie Charts}

\setkeys{Gin}{width=.8\textwidth}
\begin{frame}[fragile]
  \frametitle{Dodged Bar Graph: Code}
<<echo=TRUE>>=
require(rJava)
require(xlsx)
require(reshape2)
dat <- read.xlsx(file = "barchart.xlsx", 1)
ldat <- melt(dat)
colnames(ldat)[1] <- "group"
p <- ggplot(ldat,
  aes(x = variable, y = value, fill = group)) +
  geom_bar(stat = "identity", position = "dodge")
@
\note{
  \begin{itemize}
    \item First load the  \texttt{rJava} and \texttt{xlsx} packages to read in .xlsx files, and the \texttt{reshape2} package for the \texttt{melt} function, which melts data from wide to long. \texttt{ggplot2} generally uses long data, so after reading the excel sheet in, we convert it to long, and then change the first column name to ``group''
    \item to make the graph, call the \texttt{ggplot} function, which sets up the ``base'' of the graph.  The data frame containing the variables comes first, \texttt{ldat} (for long dat), then the variables are mapped to aspects of the graph using \texttt{aes}.
    \item on the x axis is ``variable'' on the y axis is the ``value'' and the fill is ``group''
    \item so far, there is no graph, as there is no geometric representation of our mappings; by adding \texttt{+} \texttt{geom\_bar()}, the abstract mapping is graphed using bars.  The x position of each bar is the variable, the height is the value, and the inside of the bars are filled with different colours based on group.
    \item a few additional options to \texttt{geom\_bar} complete it.  To make the bars be side by side, we ``dodge'' their positions
    \item all of this is saved to the object, \texttt{p}
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dodged Bar Graph: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p); presplots <- list(bar1 = p)
@
\end{figure}
\note{
  \begin{itemize}
    \item we saw how to create the graphical object (called a grob) previously, but nothing was \emph{rendered}
    \item in a typical interactive session, the graph would be rendered to a graphics device automatically, but here I am writing a script that includes \texttt{R} and \LaTeX code to create a presentation.
    \item you can render a saved grob by \texttt{print}ing it.
    \item the semi colon is just to allow two commands to be put on the same line, we save the grob as ``bar1'' into a list (which can eventually contain many grobs) and store the list in the object \texttt{presplots}.  This is because we will be reusing some of these later.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Customizing Labels: Code}
We can customize the barplot adding our own axis labels, changing the colour scheme, adding an overall title, and changing the theme to black and white.
<<echo=TRUE>>=
p <-
  p +
  labs(x = "Months", y = "") +
  scale_fill_grey(name = "Hospital") +
  opts(title = "Monthly Hospital Expenditures") +
  theme_bw()
@
\note{
  \begin{itemize}
    \item One implication of the grammar of graphics is you can flexibly extending existing plots (just like sentences) by adding more.
    \item We previously made a dodged bar graph and stored the grob in \texttt{p}.
    \item We extend it by setting our own x- and y-axis labels using \texttt{labs}, controlling the color of the bars by using a grey scale fill with \texttt{scale\_fill\_grey}, adding an overall title using \texttt{opts}, and setting the theme to black and white (rather than the greyish background default) using \texttt{theme\_bw}
    \item we again save the old grob plus our additions into the object \texttt{p}
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Customizing Labels: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p)
@
\end{figure}
\note{
  \begin{itemize}
    \item We can see our title at the top center, x axis label at bottom center, by putting an empty character for y axis label, it is empty, and the bars are now grey scale (as is the legend).
    \item the black and white theme means that the plot background is white instead of the default grey
    \item by the way, the default grey was chosen theoretically---articles or books tend to be a mix of white paper and black text for an overall greyish appearance.  This makes plots ``jump out'' if they are on a stark white background.  That grey was designed to make them flow with the text more.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Customizing Labels II: Code}
\begin{itemize}
  \item This demonstrates how you can even label strange things (e.g., ``x1 - x6'') by creating dates and extracting the month names.
  \item The code looks complex because the original data were called ``x1 - x6''.  Had it been date class data (e.g., ``2012/6/2''), it would be easy to make the labels just the month names.
\end{itemize}
<<echo=TRUE>>=
p <-
  p +
  scale_x_discrete(breaks = paste0("x", 1:6), labels =
  months(as.Date(paste0("2012/", 1:6, "/01"), "%Y/%m/%d"))) +
  opts(axis.text.x = theme_text(angle = 45))
@
\note{
  \begin{itemize}
    \item Now we are going to take the previous graph a few steps farther, by using month names (January through June) for the tick labels rather than ``x1 - x6''.  This is done using \texttt{scale\_x\_discrete}.  \texttt{scale\_x\_} could take either \texttt{continuous} or \texttt{discrete}.  We use \texttt{discrete} because the original values were discrete ``x1''.  Had they been numeric, ``1 - 6'', we would have used \texttt{continuous}.
    \item We also rotate the tick labels to make them fit better and be more aesthetically pleasing for their length.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Customizing Labels II: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p)
@
\end{figure}
\note{
  \begin{itemize}
    \item and here as before is the result rendering the updated grob
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stacked Bar: Code}
<<echo=TRUE>>=
dat2 <- read.xlsx(file = "barchart2.xlsx", 1)
ldat2 <- na.omit(melt(dat2))
colnames(ldat2)[1] <- "group"
cols <- colorRamp(c("lightblue", "blue"))(
  seq(0, 1, length.out = 11))
cols <- rgb(cols[, 1], cols[, 2], cols[, 3],
  maxColorValue = 255)
p <- ggplot(ldat2,
  aes(x = variable, y = value, fill = group)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = cols)
@
\note{
  \begin{itemize}
    \item This new bar graph will be stacked instead of dodged.  As before we read the data from Excel, convert to long, and rename the first column to ``group''.
    \item \texttt{na.omit} is used to drop missing (NA) values
    \item We can setup our own colour scheme using the \texttt{colorRamp} function to create a linear interpolation from lightblue to blue.  Then we extract 11 equidistant colours from this continuous ``ramp''.  Then use the \texttt{rgb} function to convert the RGB colours from \texttt{colorRamp} to hexadecimal for \texttt{ggplot2}.
    \item The data frame is \texttt{ldat2}, ``variable'' is on the x axis, ``value'' is on the y axis, ``group'' is the fill
    \item The plotting object/shape is a bar, but this time, we use the ``stack'' position rather than dodged.
    \item We can use \texttt{scale\_fill\_manual} to override the default colour scheme with our vector of colours, \texttt{cols}.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stacked Bar: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p)
@
\end{figure}
\note{
  \begin{itemize}
    \item When the colours are manually set, both the plot and the legend colours are updated so they match.
    \item This is a bit difficult to read because with 11 different shades from light blue to blue, the contrast between each one is small.  The legend is also rather large.  one option could be to place the text labels in the graph itself.  Another option could be to use more disparate colours, so the contrast is higher and it is easier to tell them apart.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pie Graph: Code}
Remember this? Using polar coordinates, it is a pie chart.
<<echo=TRUE>>=
p <- ggplot(ldat,
  aes(x = "", y = value, fill = group)) +
  geom_bar(width=1, position = "fill") +
  coord_polar(theta = "y") +
  facet_wrap(~variable)
@
\note{
  \begin{itemize}
    \item the pie graph does not really need an ``x'' variable, but it does need something there, so I just used quotes
    \item for the bars, we used ``stat = "identity"'', but here we do not because each pie graph needs to sum to 1, so a transformation is silently done to percentages
    \item By using polar coordinates, the filled bar plots are wrapped in a circle, creating a pie
    \item \texttt{facet\_wrap} breaks it down by each level of variable to give us six nice pie graphs
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pie Graph: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p)
@
\end{figure}
\note{
  \begin{itemize}
    \item Each pie graph is essentially a filled bar wrapped around a circle
    \item the faceting creates six pie graphs, so that each one corresponds to a bar from the bar graph
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pie Graph: Advanced Code}
\begin{figure}
<<echo=TRUE>>=
require(grid) # has viewport function
vp <- viewport(width = .5, height = .3, x = 1, y = 0,
  just = c("right", "bottom"))
p <- p +
  opts(title = "Pie chart with Inset Bar chart\n",
    plot.margin = unit(c(-5, 0, 0, 0), "lines"))
@
\end{figure}
\note{
  \begin{itemize}
    \item With a bit of extra work, we can add the bar chart to the pie chart
    \item first we create a viewport that is located at x = 1, y = 0, and is right bottom justified
    \item x = 1 and y = 0 are in figure coordinates, that is the figure is scaled to a [0, 1] region, so these represent the bottom right corner
    \item then we tweak the pie graphs just a bit by adding a title and adjusting the margin
    \item the last step occurs next, during printing
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pie Graph: Advanced Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p); print(presplots$bar1, vp = vp)
@
\end{figure}
\note{
  \begin{itemize}
    \item We have printed graphical objects (grobs) before using the \texttt{print(p)} idiom
    \item Now there is a second call to print, this time using the bar chart we saved from awhile back and using the viewport we made.  This causes it to print the graph, but rather than printing it in the whole figure, it just prints it in the little region we setup with the viewport.
  \end{itemize}
}
\end{frame}

\subsection{Line and Scatter Plots}

\begin{frame}[fragile]
  \frametitle{Line Chart: Code}
Here we are going to look at line and scatter plots.  We create a base plot, but do not add shapes (lines or points, so we can demonstrate them.
<<echo=TRUE>>=
dat3 <- read.xlsx(file = "linechart.xlsx",
  1, header = FALSE)
ldat3 <- melt(dat3)
colnames(ldat3)[1] <- "group"
ldat3$variable <- as.numeric(ldat3$variable)

p <- ggplot(ldat3, aes(x = variable, y = value,
  colour = group))
@
\note{
  \begin{itemize}
    \item The setup here is the same as before, read in data, make it long, and rename.
    \item We force the variable to be numeric using the \texttt{as.numeric} function
    \item The plot is almost exactly like everything else we have seen---we map some variable to x, y, but instead of trying to ``fill'' lines, we ``colour'' them by group.  Then the geometric object we will use is \texttt{geom\_line} instead of \texttt{geom\_bar}.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Line Chart: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p + geom_line())
@
\end{figure}
\note{
  \begin{itemize}
    \item Now we have a line plot, with separate lines for each group, each line coloured separately, and a legend automatically made.
    \item We are actually going to try several different geometric objects, just to show the options and how they work
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Scatter: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p + geom_point())
@
\end{figure}
\note{
  \begin{itemize}
    \item Now we have a scatter plot, with separate point colours for each group, and a legend automatically made.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Scatter \& Line: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
print(p + geom_line() + geom_point())
@
\end{figure}
\note{
  \begin{itemize}
    \item Now we have a scatter plot and a line plot, just by adding both geometric shapes.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Scatter \& Line: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 7, height = 5>>=
p <- p + geom_line() + geom_point(aes(shape = group))
print(p)
@
\end{figure}
\note{
  \begin{itemize}
    \item Now in addition to separate colours, we have different shapes.
  \end{itemize}
}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Customizing Legend: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 5.5>>=
p <- p + opts(legend.key.width = unit(1, "cm"))
print(p)
@
\end{figure}
\note{
  \begin{itemize}
    \item We can alter the legend (e.g., to make it wider and more easily visible) by adding an option setting the width.
  \end{itemize}
}
\end{frame}

\subsection{Chloropleth Maps}

\begin{frame}[fragile]
  \frametitle{Chloropleth Map: Data Setup I}
<<>>=
require(maps)
require(mapproj)

states <- map_data("state")[,
  c("long", "lat", "group", "order", "region")]
colnames(states)[5] <- "state"

## original data source
## dat <- read.csv("http://www.census.gov/popest/data/
##  national/totals/2011/files/NST_EST2011_ALLDATA.csv")

dat <- read.csv("popdata.csv")
@
\note{
  \begin{itemize}
    \item Now we are going to go in a bit of a different direction and look at how to create maps and plots of geospatial data on a map.
    \item first we will load some packages, \texttt{maps} and \texttt{mapproj}, \texttt{mapproj} allows for different projects of coordinates into a two dimensional space.
    \item We also need to get some data, from the \texttt{maps} package, we can get some state data (to create a map of the US with state borders) and from the US census, we will get birth and population data.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Chloropleth Map: Data Setup II}
<<>>=
births <- with(dat, {
  data.frame(state = tolower(NAME),
  kbirths2011 = BIRTHS2011/1000,
  mpop2010 = CENSUS2010POP/1000000)
})

births <- subset(births, state %in% states$state)
@
\note{
  \begin{itemize}
    \item Before the data are ready to use, we need to manipulate them some.  We start with the census data converting the state names to lower case to match with our geospatial state data.
    \item we also convert births to births in thousands and population to millions
    \item the results are saved in a new data frame, births.  Then, we subset the births data to only include those observations whose state names match the state names in our geospatial states data.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Chloropleth Map: Code}
<<>>=
chloropleth <- merge(states, births, "state")
chloropleth <- chloropleth[order(chloropleth$order), ]

p <- ggplot(chloropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = kbirths2011)) +
  geom_polygon(data = states, colour = "white", fill=NA) +
  scale_fill_gradientn(name = "Births in\nthousands",
    guide = guide_colorbar(),
    colours = c("blue", "red"),
    limits = c(0, 550)) +
  coord_map(projection = "mercator")
@
\note{
  \begin{itemize}
    \item The final step to a working data frame is to merge the two births and state geospatial data by state name.
    \item we see the familiar call to \texttt{ggplot} specifying the data frame, longitude is the x axis, latitude the y, and break it down by group.
    \item we add polygons (which will be the shape of the states) that are filled with the continuous variable thousands of births.
    \item we also add unfilled polygons that just have their outlines traced so it is easy to distinguish states
    \item finally we set the colours for the continuous births gradient to go from blue to red, and tell \texttt{ggplot} that the data are map data and to use the mercator projection.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Chloropleth Map: Graph}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 9, height = 6>>=
print(p)
@
\end{figure}
\note{
  \begin{itemize}
    \item here are the beautiful results of our work
    \item Alaska and other US provinces are left off, so we are just looking at the continental US.  The legend is a nice colour bar with gradient showing the births in thousands.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Chloropleth Map Advanced: Code}
<<>>=
tmp <- chloropleth[cumsum(rle(chloropleth$state)$lengths),]

p <- p +
  labs(x = "Longitude", y = "Latitude") +
  geom_point(data = tmp,
    aes(long, lat, size = mpop2010, group = 1)) +
  scale_size_continuous(guide = FALSE, range = c(4, 10)) +
  opts(title =
  "2011 US Births, 2010 population shown in bubbles\n")
@
\note{
  \begin{itemize}
    \item If we had other data, we could also add that to our map. For example, from the census, we have the 2010 population of each state.  We create a new dataset, \texttt{tmp} that is a subset of the full \texttt{chloropleth} data with just one observation per state.
    \item We can then use this new dataset, to plot the population of each state as a bubble plot.  Something similar could be done with, for instance, county level data about mortality from heart disease or other diseases.
  \end{itemize}
}
\end{frame}

\setkeys{Gin}{width=1\textwidth}
\begin{frame}[fragile]
  \frametitle{Chloropleth Map Advanced: Graph}
\begin{figure}
<<fig=TRUE, echo=FALSE, width = 9, height = 6>>=
print(p)
@
\end{figure}
\note{
  \begin{itemize}
    \item Note that there is no legend for bubble size because we turned it off using \texttt{guide = FALSE} earlier.
    \item In this case, the locations of the bubbles are not very sensible, but if we had the latitude and longitude of the centers of states or state capitals or something like that, it would work quite well.
  \end{itemize}
}
\end{frame}


\section{Gene Expression}
\note{
  \begin{itemize}
    \item I know this is different from what most of you are probably doing in your work, but I wanted to show it anyway, because it can give you ideas of what \texttt{R} can do and also potentially novel graphs or ways to visualize your own data.
    \item heatmaps of gene data are essentially just plots of matrices.  If you have any matrix data, you could use this technique with it.  For example, correlation or covariance matrices.
  \end{itemize}
}

\begin{frame}[fragile]
  \frametitle{Gene Heatmap: Code}
<<>>=
## install.packages("BiocInstaller", repos =
## "http://www.bioconductor.org/packages/2.11/bioc")
## require(BiocInstaller)
## biocLite("ALL")

require(ALL)
require("gplots")

data("ALL")
x <- exprs(ALL)[1:60, ]
@
\note{
  \begin{itemize}
    \item First we load the \texttt{ALL} package, because it has some gene expression (microarray) data.  We also load a new graphing package, called, \texttt{gplots}.  This actually builds on traditional or base graphics.
    \item Next we can bring in the data, and extract just the first 1 through 60 rows and store it in the matrix \texttt{x}.
  \end{itemize}
}
\end{frame}

\setkeys{Gin}{width=.8\textwidth}
\begin{frame}[fragile]
  \frametitle{Gene Heatmap: Graph I}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 8, height = 6>>=
heatmap(x)
@
\end{figure}
\note{
  \begin{itemize}
    \item \texttt{heatmap} is actually in core \texttt{R} not \texttt{gplots}.  It just needs one argument: the matrix to be plotted.  It automatically standardizes it, uses a clustering algorithm to create the dendrograms, and creates the nice final plot.
  \end{itemize}
}
\end{frame}

\setkeys{Gin}{width=.7\textwidth}
\setkeys{Gin}{height=.6\textheight}

% \begin{frame}[fragile]
%   \frametitle{Gene Heatmap: Graph II}
% \begin{figure}
% <<fig=TRUE, echo=TRUE, width = 7, height = 7>>=
% heatmap.2(x, scale = "row", col = redgreen(256),
%   trace = "none")
% @
% \end{figure}
% \note{
%   \begin{itemize}
%     \item
%   \end{itemize}
% }
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Gene Heatmap: Graph III}
% \begin{figure}
% <<fig=TRUE, echo=TRUE, width = 7, height = 7>>=
% heatmap.2(x, scale = "row", col = redgreen(256),
%   trace = "none", cexCol = 0.4, cexRow = 0.5)
% @
% \end{figure}
% \note{
%   \begin{itemize}
%     \item
%   \end{itemize}
% }
% \end{frame}

\begin{frame}[fragile]
  \frametitle{Gene Heatmap: Graph IV}
\begin{figure}
<<fig=TRUE, echo=TRUE, width = 7, height = 7>>=
heatmap.2(x, scale = "row", symkey=TRUE,
  col = colorpanel(256, "blue", "black", "yellow"),
  trace = "none", cexCol = 0.4, cexRow = 0.5)
@
\end{figure}
\note{
  \begin{itemize}
    \item We can customize the plot a lot more using the \texttt{heatmap.2} function in the \texttt{gplots} package.
    \item here, we tell it to scale (standardize) the matrix by row (column is also an option), ask for the key to be symmetric (so equally centered around 0).  It is common for heatmaps to be red/black/green, but this is not very colorblind friendly, so instead we could use blue/black/yellow.
    \item Because there are so many labels, we shrink the text size to make it fit better using \texttt{cexCol} and \texttt{cexRow} (which stands for \textbf{c}haracter \textbf{ex}pansion).
  \end{itemize}
}
\end{frame}

% \begin{frame}[fragile]
%   \frametitle{Gene Heatmap: Graph V}
% \begin{figure}
% <<fig=TRUE, echo=TRUE, width = 7, height = 7>>=
% heatmap.2(x, scale="row", col=redgreen(256), trace="none",
%   cexCol=.4, cexRow=.5, key = FALSE, dendrogram = "none",
%   margins = c(2, 4), lwid = c(0.1, .9), lhei = c(0.05, .9))
% @
% \end{figure}
% \note{
%   \begin{itemize}
%     \item
%   \end{itemize}
% }
% \end{frame}

% \section{References \& Notes}

% \begin{frame}[allowframebreaks]{Bibliography}
% \bibliographystyle{abbrv}
% \bibliography{jw_statistics_refs}
% \end{frame}
%\begin{frame}[allowframebreaks]
%\frametitle{Endnotes}
%\theendnotes
%\end{frame}
\end{document}
