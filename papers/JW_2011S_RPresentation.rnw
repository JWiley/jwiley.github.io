\documentclass[hyperref={colorlinks=true}]{beamer}
\mode<presentation> {
  \usetheme{Boadilla}
}
\mode<handout> {
  \usetheme{default}
  \usepackage{pgfpages}
  \pgfpagesuselayout{4 on 1}[letterpaper,landscape,border shrink=5mm]
}
\usepackage{amsmath, amsthm, amssymb, Sweave, endnotes, hyperref}
\title[R Packages]{Creating Packages in R \\ In House Presentation}
\author[J. Wiley]{Joshua Wiley}
\institute[UCLA]{
  Statistical Consulting Group \\
  University of California, Los Angeles \\
  \texttt{wileyj@ucla.edu}
}
\date[Summer 2011]{Wednesday, 10 August, 2011}

\SweaveOpts{keep.source=TRUE}

\begin{document}
<<echo=FALSE>>=
options(width = 60)
@
\renewcommand{\baselinestretch}{1.15}
\normalsize

\begin{frame}[plain]
\maketitle
\end{frame}
\begin{frame}[plain]
\begin{quotation}
Oh, gosh, this is getting whimsical.
R, I surmise, is a mutable tool that enables the user to do what they want.
Knapped flint for the Stone Age statistical fool, plasma arc for the expert and
learned savant.
R is a friend to all manner of men. The perfect companion, the servant
complete. It gently informeth the clueless and then, reveals the essence unto
the esthete.\\
   -- Jim Lemon (in a discussion about the usability of R)\\
      R-help (May 2006)
\end{quotation}
\end{frame}

%% \begin{frame}[plain]
%% \tableofcontents
%% \end{frame}
\AtBeginSection[] {
\begin{frame}{Table of Contents}
\tableofcontents[currentsection]
\end{frame}
}
\section{Basics}
\begin{frame}{Background}
\begin{itemize}
  \item \href{http://www.r-project.org/}{R} is composed of a core set of packages that provide infrastructure and basic functionality. These are well maintained and thoroughly tested.
  \item Minor versions are released every 6 months
  \item Over 3,200 community developed add on packages (available from \href{http://cran.r-project.org/}{CRAN}) extend functionality to virtually any task
\end{itemize}
\begin{center}
\textbf{Please stop me if you have questions!}
\end{center}
\end{frame}

\begin{frame}{Technical Notes I}
\begin{itemize}
  \item The R is based on S and is (mostly) a functional language
  \item Core R only runs on a single thread presently\endnote{There are add on packages, notably \href{http://cran.r-project.org/web/packages/snow/index.html}{snow}, \href{http://cran.r-project.org/web/packages/snowfall/index.html}{snowfall}, \href{http://cran.r-project.org/web/packages/Rmpi/index.html}{Rmpi}, \href{http://cran.r-project.org/web/packages/multicore/index.html}{multicore}, \href{http://cran.r-project.org/web/packages/foreach/index.html}{foreach}, \href{http://cran.r-project.org/web/packages/doMC/index.html}{doMC}}.  This is in the process of changing.
  \item \textbf{R runs in memory}\endnote{Workarounds exist but tend to be problem specific (e.g., use a data base, incremental computations for linear models, etc.)} --- operations on data are typically fast as long as the data ``fit''
  \item R is case sensitive
  \item Many functions are vectorized (operate on entire vector at once)
  \item There are a number of GUIs and other programs coming out to make getting started easier (e.g., \href{http://rstudio.org/}{Rstudio} \& \href{http://www.deducer.org/pmwiki/index.php?n=Main.DeducerManual}{Deducer})\endnote{I am old fashioned and just prefer a solid text editor (\href{http://www.gnu.org/software/emacs/}{Emacs} with \href{http://ess.r-project.org/}{Emacs Speaks Statistics})}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Getting Started I}
Let's look at a simple example session.
<<>>=
x <- c(1, 3, 5, 7, 9)
x
@
I \textbf{c}ombined the numbers into a vector assigned using ``\texttt{<-}'' to \texttt{x}.  Functions are called by their name, followed by an open and close parenthesis ``()``.  Arguments are separated by a ``,''.  Here, the numbers were the arguments.  When I typed \texttt{x} at the console, \texttt{R} \textbf{show}ed the values of the vector back to me.  Note the number on the left---R indexes starting at \textbf{1} not 0.  Because I did this assignment at the console, \texttt{x} is in the global environment\endnote{Every package has its own special environment, and the insides of functions have environments.  User's typically do not need to care about this, but it can become important when you have the same variable name used in different environments with different data.}.
\end{frame}

\begin{frame}{Technical Notes II}
You just saw the most common type of data in R --- a vector of class numeric.  Vectors are the basic data structure that underlies everything else.  \emph{A vector can only contain one class of data}.
\begin{itemize}
  \item Class hierarchy---the highest class determines class of vector
  \item raw < logical < integer < real < complex < character < list
  \item matrices and arrays \emph{are} vectors with more complex indexing
  \item each element of a list can be a vector $\therefore$ each element of a list can contain different data classes
  \item data frames \emph{are} lists with each vector constrained to equal length
  \item data frames in R parallel data sets in SPSS, SAS, etc.
  \end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Getting Started II}
These are basic functions that work on many types of data structures and classes.
<<>>=
str(x)
summary(x)
@
First we saw the \textbf{\texttt{str}}ucture of ``x'' and then got a simple summary.
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Getting Started III}
<<scatterplot1, height=4,width=5,fig=TRUE,include=FALSE>>=
plot(x)
@
\vspace{-.8in}
\includegraphics[width=\textwidth]{JW_2011S_RPresentation-scatterplot1.pdf}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Technical Notes III}
Missing values are represented as \texttt{NA} and do not behave as other data.
<<>>=
x <- c(x, NA)
x
x > 3
is.na(x)
@
Many statistical functions use the argument \texttt{na.rm = TRUE} to \textbf{r}e\textbf{m}ove missing values (often not the default).
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Getting Started IV}
We saw \texttt{c} combine two vectors. Let's look how ``x'' is treated with an NA value.
<<>>=
length(x)
summary(x)
mean(x)
mean(x, na.rm = TRUE)
@
R usually forces the user to choose how to handle missingness.
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Technical Notes IV}
\texttt{as.*} functions attempt to coerce class
<<>>=
class(x)
as.character(x)
x <- c(x, "4")
class(x)
as.numeric(x)
@
\emph{always know your data str()ucture} before you manipulate or analyze it.
\end{frame}

\section{Getting Help}

\begin{frame}{Introduction}
In the previous section, we saw the basics of how R works with and handles data.  This section is devoted to how to find out information on your own.  What do you do if you are lost and on your own?  We will cover
\begin{itemize}
  \item How to learn about specific functions
  \item How to learn how to use a function
  \item How to find a function that does what you want
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{What does \texttt{foo} do?}
Bring up the relevant documentation/help page by typing one of:
\begin{verbatim}
> help("mean")
> ?mean
\end{verbatim}
\end{frame}

\begin{frame}{Sections of R Documentation}
R documentation files have a standard format.
\begin{description}
  \item[Title] The title of the function(s), data, or whatever being documented
  \item[Description] A few sentence summary of what the purpose of the topic is
  \item[Usage] An example of the function written out (though not with real data).  How it would be used.
  \item[Arguments] All the possible arguments to the function(s) including types, valid values, names, etc.
  \item[Details] Further details often to augment the arguments section or explain ``how''
  \item[Value] What is returned by the function?
  \item[Examples] Ready-to-use examples of the function at work
\end{description}
\begin{center}
\textbf{Demo here}
\end{center}
\end{frame}

\begin{frame}[containsverbatim, allowframebreaks]
\frametitle{Using functions}
Figuring out how to use a new function can be tricky\endnote{Conscientious package writers make sure their functions are clearly named, thoroughly documented, and come with examples of common usage.}.  These tools help.
<<>>=
## show all the argument names
args(help.search)
## have examples run at the console
example(mean)
@
Note the change in the prompt when examples are run.
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{What if I do not know \texttt{foo}?}
<<echo=FALSE>>=
r <- getOption("repos")
r["CRAN"] <- "http://cran.stat.ucla.edu"
options(repos = r); rm(r)
@
<<>>=
apropos("cov")
@
<<>>=
## use the 'sos' package
install.packages("sos")
require(sos)
## not run
# findFn("multinomial logistic")
@
Also look at \href{http://crantastic.org/}{crantastic}.
\begin{center}
\textbf{Demo here}
\end{center}
\end{frame}

\section{Data sets}

\begin{frame}{Introduction}
In the previous section, we saw the basics of how R works with and handles data.  In this section, we will look at how to work with more realistic data structures.  We will cover
\begin{itemize}
  \item Matrices, data frames (the real workhorse), and lists
  \item Extraction --- how to access specific pieces of your data
  \item Glimpse at how to use functions on whole datasets or many variables at once
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim, allowframebreaks]
\frametitle{Matrices}
Matrices are simply vectors that are indexed on two dimensions.  They are indexed with typical \texttt{[row, column]}.
<<>>=
X <- matrix(1:10, nrow = 2)
X
@
As suggested by the row and column headings, particular cells can be extracted using `[` (the extraction operator)
<<>>=
X[1, 4]
@
Now lets compare extraction with the vector $x$ with the matrix $\mathbf{X}$
<<>>=
x[1]
X[1, 1]
@
But remember I said matrices \emph{are} vectors, so we can \textit{also} index them as vectors
<<>>=
X[1:5] # extract first 5 elements of the matrix
@
Notice the numbers are 1, 2, 3, 4, 5.  R indexes by columns not rows.
\newpage
Now that we are dealing with more complex structures, the class will be different:
<<>>=
class(X) # X is a matrix
str(X) # 2 x 5 integer matrix
@
\end{frame}

\begin{frame}[containsverbatim, allowframebreaks]
\frametitle{data frames}
On the surface, data frames seem very similar to matrices.  They are also two dimensional matrix-like objects.  The important difference is that each column of a data frame is its own vector.  This allows for different classes in each column (``variable'').
<<>>=
dat <- data.frame(Age = c(50, 30, 40, 50),
  Name = c("Jill", "Jack", "Jennifer", "John"))
dat
@
Notice that essentially I created two vectors with \texttt{c} and passed both of them to the \texttt{data.frame} function. Adding \texttt{Age =} named the variables\endnote{Note it is also possible to name columns and rows in matrices, but it is less common because different columns do not necessarily represent different variables.}.
<<>>=
class(dat)
str(dat)
@
\texttt{str()} demonstrates something very important.  The ``Name'' variable is not a character.  It was automatically converted to a factor.  The factor class is special in that underneath it is numeric, but has character label representations.  When used models, some form of contrast codes will be automatically applied to factor class variables\endnote{so-called ``treatment'' contrasts by default for unordered factors and orthogonal polynomial contrasts for ordered factors}.

What happens if we try to convert the data frame to a matrix?
<<>>=
as.matrix(dat)
@
Note that everything is character class now (indicated by the double quotes).  Matrices only contain one class and character is higher than numeric, so everything is elevated to character.
\newpage
Data frames can be indexed like a matrix
<<>>=
dat[2, 1]
@
Or using the variable names
<<>>=
dat[2, "Age"]
dat[3:4, "Age"] # rows 3 AND 4
@
Earlier I said that data frames \emph{are} lists with the added constraint that each element has to be the same length (so it works as a table).  This means there are some more options for extraction.
<<>>=
dat$Age
dat[["Age"]]
dat["Age"]
@
The \texttt{\$} is a convenient shortcut and often used.  Note that it is \emph{not} quoted.  You also cannot easily pass variables to it\endnote{so if you have all the columns you want to extract stored in a character vector, you would need to use $'['$ not '\$'}.  Also compare the double vs. single bracket.  Double brackets drop the name of the variable and just returns the vector, single brackets keep the data frame form.

If one of the dimensions is left blank (for both matrices and data frames), the entire dimension is selected.
<<>>=
dat[1, ] # all of row one
X[2, ] # all of row two
@
\end{frame}

\begin{frame}[containsverbatim, allowframebreaks]
\frametitle{lists}
Lists are useful because they can be used to combine almost any set of objects.  Each element of a list can be a vector (as in data frames), or the element could itself be a data frame, or matrix, or the results of a model fit you want to store.  Thus lists are extremely flexible ways to say, ``this set of objects belongs together although it may not be as structured as a table''.
<<>>=
mylist <- list(1, 2, 3)
mylist
@
Here you see a simple list with three elements, each a vector of length 1.  It is unnamed, so it can only be extracted using:
<<>>=
mylist[[1]]
mylist[1]
@
\newpage
A slightly more complex example
<<>>=
mylist <- list(A = 1, B = 2, C = 3)
mylist
mylist$A
mylist[[1]] #can still use the numbers
mylist[["A"]]
mylist["A"]
@
Here you can see different ways of extracting from a named list.
\newpage
Finally we will look at a complex, nested list structure.
<<>>=
mylist <- list(df = dat, mat = X, vec = x,
  char = c("ABCDEF..."))
mylist
@
Here you can see that ``mylist'' contains in the first element the data frame we made, then the matrix, the vector, and another short character vector.  To better understand the types of data in the list:
<<>>=
class(mylist)
str(mylist)
@
There are special functions that apply (or use) a function \emph{on each element} of a list.  Here is a simple example find the \texttt{dim}ensions of each object stored in the list.
<<>>=
lapply(X = mylist, FUN = dim)
@
This may seem a rather silly example, but it can become quite powerful allowing, for example, easy ways to extract the same coefficient from numerous model objects.  In a simulation study, one could store each model in a separate list element and then in one line of code extract all of the residuals, or all the parameter estimates, or extract and then average the covariance matrix.
\end{frame}

% \section{Data Manipulation}
% \section{Graphics}
% \section{Basic Statistics}
% \section{Advanced Graphics}
% \section{Statistics}
% \section{Reproducible Research}
% \section{Programming}
% \section{Classes and Methods}
\section{Writing a Package}

\begin{frame}{Introduction}
Packages in \texttt{R} provide a mechanism for organizing and sharing code and data.  Various features (such as documentation and built in checks) assist in making trustworthy code.

Packages are not difficult to create, but there are many little steps and details that must be followed.  Alhough not necessarily required, there are a variety of tools beyond R that are desirable to have if one is developing packages.

For users of the Windows OS, a \href{http://cran.r-project.org/doc/manuals/R-admin.html\#The-Windows-toolset}{tool set} is provided that bundles appropriate versions of all of these tools.  For *nix users, many of these tools are included by default (e.g., C compilers, tar, etc.)

In these slides, I will briefly demonstrate some of the steps and talk conceptually.  More detailed, prescriptive steps are \href{http://cran.r-project.org/doc/manuals/R-exts.html}{available}.
\end{frame}

\begin{frame}[containsverbatim, allowframebreaks]
\frametitle{Making}
Before developing your own package, I would try installing R and other package from source.  This will let you work out any issues related to having the necessary software available and knowing how to use it.

On Windows, I would first download and install the toolset.  Then download the sources (these are provided as tarballs).  From there open the shell and

\begin{verbatim}
> tar -xf R-Major.minor.patch.tar.gz
> cd \directory\where\tar\ball\was\unpacked
REM tweak some install settings as needed
> cd \to\where\the\make\files\are
> make all recommended
\end{verbatim}

That (roughly) gets you R compiled from source.  You will need to make sure the /bin/ directory for the version of R you want to be using is added to the Windows \texttt{PATH} environment variable (this can be tricky if you do not have admin privileges).

Now you can install any package tar balls easily.
\begin{verbatim}
> R CMD INSTALL /path/Package_name.version.tar.gz
\end{verbatim}

and the package is installed.  Suppose you have the raw source (from your own package, for instance) and you want to make a tar ball, just add the build option.  A variety of other options exist and can be seen as usual in a shell \texttt{R CMD INSTALL -\--help}.

\begin{verbatim}
> R CMD INSTALL --build /path/Package_name.version.tar.gz
\end{verbatim}
\end{frame}

\begin{frame}{Preparing for your Package}
After you have a few functions written, it may be time to put them together in a package.  A number of utility functions help partially automate the process of creating the appropriate directories and files.\\

Specifically, \texttt{package.skeleton} can be used with several code files or functions to create a package skeleton.  Once this initial step has been done, to continue adding later, use \texttt{prompt}, \texttt{promptMethods}, \texttt{promptClass}.\\

See \texttt{?package.skeleton} and the Writing R Extensions manual for more details.
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{A Simple Package}
The most basic package requires a description file and a namespace file, and subdirectories for the R code (``R''), the documention (``man''), and data (if present, ``data'').

The description file describes the package.  This is used by \texttt{R} to determine things like the package version, other packages your package depends on, etc.
\begin{center}
  \textbf{Demo here}
\end{center}
This is created automatically by \texttt{package.skeleton}, but you have to fill it in.  Most the fields make sense, but note the ``Depends'', ``Imports'', and ``Suggests'' lines.  These list packages that my package \emph{depends} on (\texttt{R}, the core packages, \texttt{methods}, and some graphcis ones);
\newpage
imports (i.e., uses select functions from, but does not necessarily require them to be fully loaded to operate); and suggests (may enhance functionality or be similar, but not needed).

\texttt{R} knows about certain licenses, so for GPL-2 and GPL-3, it is enough to specify their name.  GPL-3 is the preferred now, I believe.  Briefly, it makes provisions that your code may be copied, changed, and redistributed, but if it is still your code it must be redistributed freely, open source, and able to be altered and reredistributed, etc.
\end{frame}

\begin{frame}[containsverbatim, allowframebreaks]
\frametitle{The Namespace}
The development version of \texttt{R} requires that all packages have a namespace.  If there is not one, it tries to create one, but you should write your own.

How R uses namespaces is non-trivial and has to do with lexical scoping\footnote{drawings and explanations here if desired}.  In the package namespace file, you just need to specify the functions (or classes or methods) that you want to be available to users.

For instance, I might write some high level function \texttt{WriteManuscript()} that I want users to be able to directly call to write their manuscripts for them.  \texttt{WriteManuscript} in turn calls some internal (non exported) workhorse functions \texttt{RARecruit()}, \texttt{ReviewerRebuttler()}, \texttt{Dejargonfier()}.

These ``workhorse'' functions are not meant to be used directly.  Reasons may include requiring very specialized input, not checking for valid values (that may be assumed to be done by the higher level \texttt{WriteManuscript}).

If needed, nonexported functions can be accessed using fully qualified references.  For example
<<>>=
require(Jmisc) # load my package
cat(try(star)) # not found because not expored
@
\newpage
<<>>=
Jmisc:::star # fully qualified reference works
@
The form is PackageName:::FunctionName.

The namespace file also specifies which functions should be imported from other packages.  ``Depends'' will be fully loaded and attached, ``Imports'' will be loaded but not attached to the search path.
\begin{center}
  \textbf{Demo namespace file here}
\end{center}
\end{frame}

\begin{frame}{R Code}
Adding R code to packages is probably the simplest aspect.  Simply create the text files named with the *.R extension.  You can create separate files for each function, or bundle multiple functions in one file.  It will be processed identically.  All the pure R code files go into the /R/ directory.

\begin{center}
  \textbf{Demo directory and file}
\end{center}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{R Documentation}
Trickier than including code is creating appropriate documentation for it.  This is where the \texttt{prompt*} functions we learned about earlier will help.  They create general stubs that meet the requirements.  Part of the built in checks look to make sure that every function has a corresponding documentation file and that every argument in the function's code matches the documentation of the arguments.

\end{frame}

% \begin{frame}
% % {Histogram $+$ Density}
% \begin{figure}[t]
% \begin{center}
% \includegraphics[scale=0.42]{fig_1b.pdf}
% \end{center}
% \end{figure}
% \end{frame}

\section{References \& Notes}

\begin{frame}{Notes}
  Most of the resources mentioned in this presentation are freely available on the WWW.  Hyperlinks are included for all of these as they are mentioned in the text.  These were active as of \today.
\end{frame}

% \begin{frame}[allowframebreaks]{Bibliography}
% \bibliographystyle{abbrv}
% \bibliography{jw_statistics_refs}
% \end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Endnotes}
\theendnotes
\end{frame}

\end{document}
